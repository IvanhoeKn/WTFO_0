Часть 2. Задания на прорешивание
Задание 1.

Задание 2.
Здесь все достаточно просто и логично. Будем искать все делеители числа перебором от 1 до квадратного
корня из этого числа. Т.о. мы сможем находить пары делителей, а именно i и n / i. Это обеспечивает
нам нахождение всех делителей. Среди найденных делителей необходимо будет лишь сделать проверку,
что делитель болше заданного числа - в случае если это истинно, увеличить счетчик.

Задание 3.
Если необходимо написать программу для работы с битами числа N, где N = [0, 255], то лучше
пользоваться unsigned типами, чтобы не заморачиваться с битом знака, который может иногда подпортить
погоду. Если мы ограничимся сеткой числа равной 8, то сумма числа N и его побитная инверсия в сумме 
дадут нам (2^8 - 1). 
Итак, входные данные: result.
Необходимо найти N.
result = ~N - N
Ранее мы выяснили, что 2^8 - 1 = ~N + N, тогда ~N = 2^8 - 1 - N
Значит result = 2^8 - 1 - N - N выразим отсюда N
N = (result - (2^8 - 1)) / 2
Mission is completed! =)

Задание 4.
В данной задаче используется простейший жадный алгоритм. Думаю, объяснять ничего даже не нужно.
Единственное пояснение (связано с поиском максимального элемента при максимальном количестве элементов):
для его поиска необходимо выкинуть из выбранных элементов последний, самый большой на данный момент,
после чего стоит пройтись дальше по массиву элементов для их проверки на превышение лимита S.

Задание 5.
Алгоритм достаточно прост:
выбираем из пары чисел наибольшее и суммируем его в счетчик. Также в буферную переменную записываем
x2 - x1 (x2 > x1) - данную запись производим в случае если данное число больше буферного и остаток
от деления на 3 не равен нулю.
В итоге если счетчик кратен 3, то вычитаем из него значение буферной переменной.

Задание 6.
Связано с динамическим программированием.  






